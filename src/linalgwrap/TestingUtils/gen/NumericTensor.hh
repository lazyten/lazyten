//
// Copyright (C) 2016-17 by the linalgwrap authors
//
// This file is part of linalgwrap.
//
// linalgwrap is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// linalgwrap is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with linalgwrap. If not, see <http://www.gnu.org/licenses/>.
//

#pragma once
#include "Numeric.hh"
#include "NumericContainer.hh"
#include "NumericSize.hh"
#include "linalgwrap/Base/Interfaces.hh"
#include "linalgwrap/MultiVector.hh"
#include "linalgwrap/StoredMatrix_i.hh"

namespace linalgwrap {
namespace gen {
namespace detail {

// TODO have some bounds on matrix properties as well,
//      e.g. the difference between accumulate(abs(mat)) should not
//      be too different from norm_frobenius(mat)
//      => even distribution of "size"

// TODO generalise this properly once we have tensors of larger rank.

/** Default implementation: Not allowed */
template <typename Tensor, typename Enable = void>
struct NumericTensor {
  static_assert(!std::is_same<Enable, void>::value,
                "NumericTensor is only available for stored vectors and "
                "stored tensors.");
};

/** Implementation for vectors */
template <typename Vector>
struct NumericTensor<Vector,
                     typename std::enable_if<IsStoredVector<Vector>::value>::type> {
  static rc::Gen<Vector> numeric_tensor(typename Vector::size_type count) {
    return rc::gen::cast<Vector>(
          numeric_container<std::vector<typename Vector::scalar_type>>(count));
  }

  static rc::Gen<Vector> numeric_tensor() {
    return rc::gen::mapcat(gen::numeric_size<1>(),
                           [](size_t count) { return numeric_tensor(count); });
  }
};

/** Implementation for matrices */
template <typename Matrix>
struct NumericTensor<Matrix,
                     typename std::enable_if<IsStoredMatrix<Matrix>::value>::type> {
  static rc::Gen<Matrix> numeric_tensor(typename Matrix::size_type rows,
                                        typename Matrix::size_type cols) {
    using container = std::vector<typename Matrix::scalar_type>;

    auto gen_values = numeric_container<container>(rows * cols);
    auto map_to_matrix = [rows, cols](container c) {
      Matrix m{rows, cols, false};
      std::copy(std::begin(c), std::end(c), std::begin(m));
      return m;
    };

    return rc::gen::map(gen_values, map_to_matrix);
  }

  static rc::Gen<Matrix> numeric_tensor() {
    auto pairgen = rc::gen::pair(gen::numeric_size<2>(), gen::numeric_size<2>());
    return rc::gen::mapcat(pairgen, [](std::pair<size_t, size_t> p) {
      return numeric_tensor(p.first, p.second);
    });
  }
};

/** Implementation for MultiVectors */
template <typename Vector>
struct NumericTensor<MultiVector<Vector>,
                     typename std::enable_if<IsStoredVector<Vector>::value>::type> {

  static rc::Gen<MultiVector<Vector>> numeric_tensor(size_t n_vecs,
                                                     rc::Gen<Vector> gen_vector) {
    // Generate a std::vector which has exactly n_vecs vectors with the desired number of
    // elements.
    using container = std::vector<Vector>;
    auto gen_container = rc::gen::container<container>(n_vecs, gen_vector);

    // Map to map the vector container into a multivector:
    auto map_to_multivector = [n_vecs](container c) {
      MultiVector<Vector> res;
      res.reserve(n_vecs);
      for (size_t i = 0; i < n_vecs; ++i) {
        res.push_back(std::move(c[i]));
      }
      return res;
    };

    return rc::gen::map(gen_container, map_to_multivector);
  }

  static rc::Gen<MultiVector<Vector>> numeric_tensor(typename Vector::size_type n_elem,
                                                     typename Vector::size_type n_vecs) {
    auto gen_vector = rc::gen::scale(1.2, NumericTensor<Vector>::numeric_tensor(n_elem));
    return numeric_tensor(n_vecs, std::move(gen_vector));
  }

  static rc::Gen<MultiVector<Vector>> numeric_tensor() {
    auto pairgen = rc::gen::pair(gen::numeric_size<2>(), gen::numeric_size<2>());
    return rc::gen::mapcat(pairgen, [](std::pair<size_t, size_t> p) {
      return numeric_tensor(p.first, p.second);
    });
  }
};

}  // namespace detail

/** \brief Generator for an tensor object with values generated by
 *  gen::numeric() and the size generated by gen::numeric_size() */
template <typename T>
rc::Gen<T> numeric_tensor() {
  return detail::NumericTensor<T>::numeric_tensor();
}

/** \brief Generator for a vector-like object with values generated by
 *  gen::numeric() and the provided size. */
template <typename T>
rc::Gen<T> numeric_tensor(typename T::size_type count) {
  return detail::NumericTensor<T>::numeric_tensor(count);
}

/** \brief Generator for a matrix-like object with values generated by
 *  gen::numeric() and the provided number of rows and columns. */
template <typename T>
rc::Gen<T> numeric_tensor(typename T::size_type row, typename T::size_type col) {
  return detail::NumericTensor<T>::numeric_tensor(row, col);
}

/** \brief Generator for a multivector object of n_vecs vectors, where
 *  the vectors itself are generated by the provided generator  */
template <typename MultiVector>
rc::Gen<MultiVector> numeric_tensor(typename MultiVector::size_type n_vecs,
                                    rc::Gen<typename MultiVector::vector_type> gen) {
  return detail::NumericTensor<MultiVector>::numeric_tensor(n_vecs, std::move(gen));
}

}  // gen
}  // linalgwrap
